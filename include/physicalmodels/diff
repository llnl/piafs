5c5
<   3D Navier-Stokes equations for viscous and inviscid compressible flows\n
---
>   3D Navier-Stokes equations for viscous and inviscid compressible flows (with gravitational terms)\n
15c15
<   + \left[\begin{array}{c} 0 \\ 0 \\ 0 \\ 0 \\ \frac{Q}{\gamma-1} \end{array}\right]
---
>   + \left[\begin{array}{c} 0 \\ -\rho {\bf g}\cdot{\bf \hat{i}} \\ -\rho {\bf g}\cdot{\bf \hat{j}}  \\ -\rho {\bf g}\cdot{\bf \hat{k}} \\ -\rho u {\bf g}\cdot{\bf \hat{i}} - \rho v {\bf g}\cdot{\bf \hat{j}} - \rho w {\bf g}\cdot{\bf \hat{k}} \end{array}\right]
17c17
<   where \f$Q\f$ is the chemical heating term, and the viscous terms are given by
---
>   where \f${\bf g}\f$ is the gravitational force vector per unit mass, \f${\bf \hat{i}},{\bf \hat{j}}, {\bf \hat{k}}\f$ are the unit vectors along the x, y, and z, the viscous terms are given by
29a30,44
> 
>   Reference for the well-balanced treatment of gravitational source term:
>   + Ghosh, D., Constantinescu, E.M., Well-Balanced Formulation of Gravitational Source
>     Terms for Conservative Finite-Difference Atmospheric Flow Solvers, AIAA Paper 2015-2889,
>     7th AIAA Atmospheric and Space Environments Conference, June 22-26, 2015, Dallas, TX,
>     http://dx.doi.org/10.2514/6.2015-2889
>   + Ghosh, D., Constantinescu, E.M., A Well-Balanced, Conservative Finite-Difference Algorithm
>     for Atmospheric Flows, AIAA Journal, 54 (4), 2016, pp. 1370-1385, http://dx.doi.org/10.2514/1.J054580.
> 
>   Reference for the partitioning of the flux into its stiff (acoustic) and non-stiff (convective)
>   components:
>   + Ghosh, D., Constantinescu, E. M., Semi-Implicit Time Integration of Atmospheric Flows
>     with Characteristic-Based Flux Partitioning, SIAM Journal on Scientific Computing,
>     38 (3), 2016, A1848-A1875, http://dx.doi.org/10.1137/15M1044369.
> 
30a46
> 
32,33d47
< #include <math_ops.h>
< #include <physicalmodels/chemistry.h>
35c49
< /*! 3D Navier Stokes equations */
---
> /*! 3D Navier-Stokes equations */
40c54
< #undef _NS3D_NVARS_
---
> #undef _MODEL_NVARS_
43,44c57,58
< /*! Number of Navier-Stokes variables per grid point (rho, rho*u, rho*v, rho*w, e) */
< #define _NS3D_NVARS_ 5
---
> /*! Number of vector components at each grid point */
> #define _MODEL_NVARS_ 5
48c62
< #define _ROE_       "roe"
---
> #define _ROE_   "roe"
50c64
< #define _RF_        "rf-char"
---
> #define _RF_    "rf-char"
52c66
< #define _LLF_       "llf-char"
---
> #define _LLF_   "llf-char"
56c70
< /* directions */
---
> /* grid directions */
63a78,91
> /* immersed boundary wall types */
> /*! adiabatic immersed body wall */
> #define _IB_ADIABATIC_ "adiabatic"
> /*! isothermal immersed body wall */
> #define _IB_ISOTHERMAL_ "isothermal"
> 
> /* types of immersed boundary application ramps */
> /*! linear ramping */
> #define _IB_RAMP_LINEAR_ "linear"
> /*! smoothed slab ramp (like tanh) */
> #define _IB_RAMP_SMOOTHEDSLAB_ "smoothed_slab"
> /*! disable the immersed boundaries */
> #define _IB_RAMP_DISABLE_ "no_ib"
> 
67c95
<    {\bf u} = \left[\begin{array}{c} \rho \\ \rho u \\ \rho v \\ \rho w \\ e \\ \vdots \\ \phi_i \\ \vdots \end{array}\right]
---
>    {\bf u} = \left[\begin{array}{c} \rho \\ \rho u \\ \rho v \\ \rho w \\ e \end{array}\right]
69d96
<  where \f$\phi_i\f$ are passively-advected scalars
71c98
< #define _NavierStokes3DGetFlowVar_(u,rho,vx,vy,vz,e,P,gamma) \
---
> #define _NavierStokes3DGetFlowVar_(u,stride,rho,vx,vy,vz,e,P,gamma) \
73c100
<     double  vsq; \
---
>     double vsq; \
75,79c102,106
<     vx  = (rho==0) ? 0 : u[1] / rho; \
<     vy  = (rho==0) ? 0 : u[2] / rho; \
<     vz  = (rho==0) ? 0 : u[3] / rho; \
<     e   = u[4]; \
<     vsq  = (vx*vx) + (vy*vy) + (vz*vz); \
---
>     vx  = (rho==0) ? 0 : u[stride] / rho; \
>     vy  = (rho==0) ? 0 : u[2*stride] / rho; \
>     vz  = (rho==0) ? 0 : u[3*stride] / rho; \
>     e   = u[4*stride]; \
>     vsq  = vx*vx + vy*vy + vz*vz; \
86,88c113,115
<     dir = x, & {\bf f}\left({\bf u}\right) = \left[\begin{array}{c} \rho u \\ \rho u^2 + p \\ \rho u v \\ \rho u w \\ (e+p)u \\ \vdots \\ u \phi_i \\ \vdots \end{array}\right], \\
<     dir = y, & {\bf f}\left({\bf u}\right) = \left[\begin{array}{c} \rho v \\ \rho u v \\ \rho v^2 + p \\ \rho v w \\ (e+p)v \\ \vdots \\ v \phi_i \\ \vdots \end{array}\right], \\
<     dir = z, & {\bf f}\left({\bf u}\right) = \left[\begin{array}{c} \rho w \\ \rho u w \\ \rho v w \\ \rho w^2 + p \\ (e+p)w \\ \vdots \\ w \phi_i \\ \vdots \end{array}\right]
---
>     dir = x, & {\bf f}\left({\bf u}\right) = \left[\begin{array}{c} \rho u \\ \rho u^2 + p \\ \rho u v \\ \rho u w \\ (e+p)u \end{array}\right], \\
>     dir = y, & {\bf f}\left({\bf u}\right) = \left[\begin{array}{c} \rho v \\ \rho u v \\ \rho v^2 + p \\ \rho v w \\ (e+p)v \end{array}\right], \\
>     dir = z, & {\bf f}\left({\bf u}\right) = \left[\begin{array}{c} \rho w \\ \rho u w \\ \rho v w \\ \rho w^2 + p \\ (e+p)w \end{array}\right]
91c118
< #define _NavierStokes3DSetFlux_(f,u,gamma,nvars,dir) \
---
> #define _NavierStokes3DSetFlux_(f,stride,rho,vx,vy,vz,e,P,dir) \
93,95d119
<     double rho, vx, vy, vz, e, P; \
<     _NavierStokes3DGetFlowVar_(u,rho,vx,vy,vz,e,P,gamma); \
<     int m_i;\
98,104c122,125
<       f[1] = rho * vx * vx + P; \
<       f[2] = rho * vx * vy; \
<       f[3] = rho * vx * vz; \
<       f[4] = (e + P) * vx; \
<       for (m_i = _NS3D_NVARS_; m_i < nvars; m_i++) { \
<           f[m_i] = vx * u[m_i]; \
<       } \
---
>       f[stride] = rho * vx * vx + P; \
>       f[2*stride] = rho * vx * vy; \
>       f[3*stride] = rho * vx * vz; \
>       f[4*stride] = (e + P) * vx; \
107,113c128,131
<       f[1] = rho * vy * vx; \
<       f[2] = rho * vy * vy + P; \
<       f[3] = rho * vy * vz; \
<       f[4] = (e + P) * vy; \
<       for (m_i = _NS3D_NVARS_; m_i < nvars; m_i++) { \
<           f[m_i] = vy * u[m_i]; \
<       } \
---
>       f[stride] = rho * vy * vx; \
>       f[2*stride] = rho * vy * vy + P; \
>       f[3*stride] = rho * vy * vz; \
>       f[4*stride] = (e + P) * vy; \
116,122c134,137
<       f[1] = rho * vz * vx; \
<       f[2] = rho * vz * vy; \
<       f[3] = rho * vz * vz + P; \
<       f[4] = (e + P) * vz; \
<       for (m_i = _NS3D_NVARS_; m_i < nvars; m_i++) { \
<           f[m_i] = vz * u[m_i]; \
<       } \
---
>       f[stride] = rho * vz * vx; \
>       f[2*stride] = rho * vz * vy; \
>       f[3*stride] = rho * vz * vz + P; \
>       f[4*stride] = (e + P) * vz; \
129c144
< #define _NavierStokes3DRoeAverage_(uavg,uL,uR,nvars,gamma) \
---
> #define _NavierStokes3DRoeAverage_(uavg,stride,uL,uR,gamma) \
131,140c146,149
<     double  rho ,vx, vy, vz, e ,P ,H ,csq, vsq; \
<     double  rhoL,vxL,vyL,vzL,eL,PL,HL,cLsq,vsqL; \
<     double  rhoR,vxR,vyR,vzR,eR,PR,HR,cRsq,vsqR; \
<     rhoL = uL[0]; \
<     vxL  = uL[1] / rhoL; \
<     vyL  = uL[2] / rhoL; \
<     vzL  = uL[3] / rhoL; \
<     eL   = uL[4]; \
<     vsqL = (vxL*vxL) + (vyL*vyL) + (vzL*vzL); \
<     PL   = (eL - 0.5*rhoL*vsqL) * (gamma-1.0); \
---
>     double  rho ,vx, vy, vz, e ,P ,H; \
>     double  rhoL,vxL,vyL,vzL,eL,PL,HL,cLsq; \
>     double  rhoR,vxR,vyR,vzR,eR,PR,HR,cRsq; \
>     _NavierStokes3DGetFlowVar_(uL,stride,rhoL,vxL,vyL,vzL,eL,PL,gamma); \
143,149c152
<     rhoR = uR[0]; \
<     vxR  = uR[1] / rhoR; \
<     vyR  = uR[2] / rhoR; \
<     vzR  = uR[3] / rhoR; \
<     eR   = uR[4]; \
<     vsqR = (vxR*vxR) + (vyR*vyR) + (vzR*vzR); \
<     PR   = (eR - 0.5*rhoR*vsqR) * (gamma-1.0); \
---
>     _NavierStokes3DGetFlowVar_(uR,stride,rhoR,vxR,vyR,vzR,eR,PR,gamma); \
158,162c161,163
<     H   = (tL*HL + tR*HR) / (tL + tR); \
<     vsq = vx*vx + vy*vy + vz*vz; \
<     csq = (gamma-1.0) * (H-0.5*vsq); \
<     P   = csq * rho / gamma; \
<     e   = P/(gamma-1.0) + 0.5*rho*vsq; \
---
>     H   = (tL*HL  + tR*HR ) / (tL + tR); \
>     P = (H - 0.5* (vx*vx+vy*vy+vz*vz)) * (rho*(gamma-1.0))/gamma; \
>     e   = P/(gamma-1.0) + 0.5*rho*(vx*vx+vy*vy+vz*vz); \
168,170c169,239
<     int m_i; \
<     for (m_i = _NS3D_NVARS_; m_i < nvars; m_i++) { \
<         uavg[m_i] = sqrt(uL[m_i]) * sqrt(uR[m_i]); \
---
>   }
> 
> /*! \def _NavierStokes3DSetStiffFlux_
>   Compute the stiff flux vector (comprising the acoustic modes only), given the flow variables
>   \f{eqnarray}{
>     dir = x, & {\bf f}\left({\bf u}\right) = \left[\begin{array}{c} \frac{1}{\gamma}\rho u \\ \frac{1}{\gamma}\rho u^2 + p \\ \frac{1}{\gamma}\rho u v \\ \frac{1}{\gamma}\rho u w \\ (e+p)u - \frac{1}{2} \frac{\gamma-1}{\gamma}\rho\left(u^2+v^2+w^2\right)u \end{array}\right], \\
>     dir = y, & {\bf f}\left({\bf u}\right) = \left[\begin{array}{c} \frac{1}{\gamma}\rho v \\ \frac{1}{\gamma}\rho u v \\ \frac{1}{\gamma}\rho v^2 + p \\ \frac{1}{\gamma}\rho v w \\ (e+p)v - \frac{1}{2} \frac{\gamma-1}{\gamma}\rho\left(u^2+v^2+w^2\right)v \end{array}\right], \\
>     dir = z, & {\bf f}\left({\bf u}\right) = \left[\begin{array}{c} \frac{1}{\gamma}\rho w \\ \frac{1}{\gamma}\rho u w \\ \frac{1}{\gamma}\rho v w \\ \frac{1}{\gamma}\rho w^2 + p \\ (e+p)w - \frac{1}{2} \frac{\gamma-1}{\gamma}\rho\left(u^2+v^2+w^2\right)w \end{array}\right], \\
>   \f}
>   Reference:
>   + Ghosh, D., Constantinescu, E. M., Semi-Implicit Time Integration of Atmospheric Flows
>     with Characteristic-Based Flux Partitioning, SIAM Journal on Scientific Computing,
>     38 (3), 2016, A1848-A1875, http://dx.doi.org/10.1137/15M1044369.
> */
> #define _NavierStokes3DSetStiffFlux_(f,stride,rho,vx,vy,vz,e,P,dir,gamma) \
>   { \
>     double gamma_inv = 1.0/gamma; \
>     if (dir == _XDIR_) { \
>       f[0*stride] = gamma_inv * rho * vx; \
>       f[1*stride] = gamma_inv * rho * vx * vx + P; \
>       f[2*stride] = gamma_inv * rho * vx * vy; \
>       f[3*stride] = gamma_inv * rho * vx * vz; \
>       f[4*stride] = (e + P) * vx - 0.5 * gamma_inv * (gamma-1.0) * rho * (vx*vx+vy*vy+vz*vz) * vx; \
>     } else if (dir == _YDIR_) { \
>       f[0*stride] = gamma_inv * rho * vy; \
>       f[1*stride] = gamma_inv * rho * vy * vx; \
>       f[2*stride] = gamma_inv * rho * vy * vy + P; \
>       f[3*stride] = gamma_inv * rho * vy * vz; \
>       f[4*stride] = (e + P) * vy - 0.5 * gamma_inv * (gamma-1.0) * rho * (vx*vx+vy*vy+vz*vz) * vy; \
>     } else if (dir == _ZDIR_) { \
>       f[0*stride] = gamma_inv * rho * vz; \
>       f[1*stride] = gamma_inv * rho * vz * vx; \
>       f[2*stride] = gamma_inv * rho * vz * vy; \
>       f[3*stride] = gamma_inv * rho * vz * vz + P; \
>       f[4*stride] = (e + P) * vz - 0.5 * gamma_inv * (gamma-1.0) * rho * (vx*vx+vy*vy+vz*vz) * vz; \
>     } \
>   }
> 
> /*! \def _NavierStokes3DSetNonStiffFlux_
>   Compute the non-stiff flux vector (comprising the entropy modes only), given the flow variables
>   \f{eqnarray}{
>     dir = x, & {\bf f}\left({\bf u}\right) = \left[\begin{array}{c} \frac{\gamma-1}{\gamma}\rho u \\ \frac{\gamma-1}{\gamma}\rho u^2 \\ \frac{\gamma-11}{\gamma}\rho u v \\ \frac{\gamma-1}{\gamma}\rho u w \\ \frac{1}{2} \frac{\gamma-1}{\gamma}\rho\left(u^2+v^2+w^2\right)u \end{array}\right], \\
>     dir = y, & {\bf f}\left({\bf u}\right) = \left[\begin{array}{c} \frac{\gamma-1}{\gamma}\rho v \\ \frac{\gamma-1}{\gamma}\rho u v \\ \frac{\gamma-1}{\gamma}\rho v^2 \\ \frac{\gamma-1}{\gamma}\rho v w  \\ \frac{1}{2} \frac{\gamma-1}{\gamma}\rho\left(u^2+v^2+w^2\right)v \end{array}\right], \\
>     dir = z, & {\bf f}\left({\bf u}\right) = \left[\begin{array}{c} \frac{\gamma-1}{\gamma}\rho w \\ \frac{\gamma-1}{\gamma}\rho u w \\ \frac{\gamma-1}{\gamma}\rho v w \\ \frac{\gamma-1}{\gamma}\rho w^2  \\ \frac{1}{2} \frac{\gamma-1}{\gamma}\rho\left(u^2+v^2+w^2\right)w \end{array}\right], \\
>   \f}
>   Reference:
>   + Ghosh, D., Constantinescu, E. M., Semi-Implicit Time Integration of Atmospheric Flows
>     with Characteristic-Based Flux Partitioning, SIAM Journal on Scientific Computing,
>     38 (3), 2016, A1848-A1875, http://dx.doi.org/10.1137/15M1044369.
> */
> #define _NavierStokes3DSetNonStiffFlux_(f,rho,vx,vy,vz,e,P,dir,gamma) \
>   { \
>     double gamma_inv = 1.0/gamma; \
>     if (dir == _XDIR_) { \
>       f[0*stride] = (gamma-1.0) * gamma_inv * rho * vx; \
>       f[1*stride] = (gamma-1.0) * gamma_inv * rho * vx * vx; \
>       f[2*stride] = (gamma-1.0) * gamma_inv * rho * vx * vy; \
>       f[3*stride] = (gamma-1.0) * gamma_inv * rho * vx * vz; \
>       f[4*stride] = 0.5 * gamma_inv * (gamma-1.0) * rho * (vx*vx+vy*vy+vz*vz) * vx; \
>     } else if (dir == _YDIR_) { \
>       f[0*stride] = (gamma-1.0) * gamma_inv * rho * vy; \
>       f[1*stride] = (gamma-1.0) * gamma_inv * rho * vy * vx; \
>       f[2*stride] = (gamma-1.0) * gamma_inv * rho * vy * vy; \
>       f[3*stride] = (gamma-1.0) * gamma_inv * rho * vy * vz; \
>       f[4*stride] = 0.5 * gamma_inv * (gamma-1.0) * rho * (vx*vx+vy*vy+vz*vz) * vy; \
>     } else if (dir == _ZDIR_) { \
>       f[0*stride] = (gamma-1.0) * gamma_inv * rho * vz; \
>       f[1*stride] = (gamma-1.0) * gamma_inv * rho * vz * vx; \
>       f[2*stride] = (gamma-1.0) * gamma_inv * rho * vz * vy; \
>       f[3*stride] = (gamma-1.0) * gamma_inv * rho * vz * vz; \
>       f[4*stride] = 0.5 * gamma_inv * (gamma-1.0) * rho * (vx*vx+vy*vy+vz*vz) * vz; \
177a247,252
> 
>   The eigenvalues are \f$ {\bf v}\cdot\hat{\bf n}, {\bf v}\cdot\hat{\bf n}, {\bf v}\cdot\hat{\bf n}, {\bf v}\cdot\hat{\bf n} \pm c\f$
>   where \f${\bf v} = u\hat{\bf i} + v\hat{\bf j} + w\hat{\bf k}\f$ is the velocity vector, \f$\hat{\bf n} = \hat{\bf i}, \hat{\bf j}, \hat{\bf k}\f$
>   is the unit vector along the spatial dimension, and \f$c\f$ is the speed of sound.
>   \b Note that the order of the eigenvalues (and therefore, the order of the eigenvectors in #_NavierStokes3DLeftEigenvectors_ and
>   #_NavierStokes3DRightEigenvectors_ has been chosen to avoid left eigen-matrices with zero on the diagonals.
179c254
< #define _NavierStokes3DEigenvalues_(u,D,gamma,nvars,dir) \
---
> #define _NavierStokes3DEigenvalues_(u,stride,D,gamma,dir) \
181,194c256,264
<     double  rho,vx,vy,vz,e,P,c,vn,vsq; \
<     _NavierStokes3DGetFlowVar_(u,rho,vx,vy,vz,e,P,gamma); \
<     vsq = (vx*vx) + (vy*vy) + (vz*vz); \
<     c = sqrt(gamma*P/rho); \
<     if      (dir == _XDIR_) vn = vx; \
<     else if (dir == _YDIR_) vn = vy; \
<     else if (dir == _ZDIR_) vn = vz; \
<     else                    vn = 0.0; \
<     _ArraySetValue_(D, nvars*nvars, 0.0); \
<     D[0*nvars+0] = vn-c; \
<     if (dir == _XDIR_) {\
<       D[1*nvars+1] = vn+c; \
<       D[2*nvars+2] = vn;\
<       D[3*nvars+3] = vn;\
---
>     double          rho,vx,vy,vz,e,P,c; \
>     _NavierStokes3DGetFlowVar_(u,stride,rho,vx,vy,vz,e,P,gamma); \
>     c    = sqrt(gamma*P/rho); \
>     if (dir == _XDIR_) { \
>       D[0*_MODEL_NVARS_+0] = vx;     D[0*_MODEL_NVARS_+1] = 0;    D[0*_MODEL_NVARS_+2] = 0;      D[0*_MODEL_NVARS_+3] = 0;    D[0*_MODEL_NVARS_+4] = 0; \
>       D[1*_MODEL_NVARS_+0] = 0;      D[1*_MODEL_NVARS_+1] = vx-c; D[1*_MODEL_NVARS_+2] = 0;      D[1*_MODEL_NVARS_+3] = 0;    D[1*_MODEL_NVARS_+4] = 0; \
>       D[2*_MODEL_NVARS_+0] = 0;      D[2*_MODEL_NVARS_+1] = 0;    D[2*_MODEL_NVARS_+2] = vx;     D[2*_MODEL_NVARS_+3] = 0;    D[2*_MODEL_NVARS_+4] = 0; \
>       D[3*_MODEL_NVARS_+0] = 0;      D[3*_MODEL_NVARS_+1] = 0;    D[3*_MODEL_NVARS_+2] = 0;      D[3*_MODEL_NVARS_+3] = vx;   D[3*_MODEL_NVARS_+4] = 0; \
>       D[4*_MODEL_NVARS_+0] = 0;      D[4*_MODEL_NVARS_+1] = 0;    D[4*_MODEL_NVARS_+2] = 0;      D[4*_MODEL_NVARS_+3] = 0;    D[4*_MODEL_NVARS_+4] = vx+c;\
196,198c266,270
<       D[1*nvars+1] = vn; \
<       D[2*nvars+2] = vn+c; \
<       D[3*nvars+3] = vn;\
---
>       D[0*_MODEL_NVARS_+0] = vy;     D[0*_MODEL_NVARS_+1] = 0;    D[0*_MODEL_NVARS_+2] = 0;      D[0*_MODEL_NVARS_+3] = 0;    D[0*_MODEL_NVARS_+4] = 0; \
>       D[1*_MODEL_NVARS_+0] = 0;      D[1*_MODEL_NVARS_+1] = vy;   D[1*_MODEL_NVARS_+2] = 0;      D[1*_MODEL_NVARS_+3] = 0;    D[1*_MODEL_NVARS_+4] = 0; \
>       D[2*_MODEL_NVARS_+0] = 0;      D[2*_MODEL_NVARS_+1] = 0;    D[2*_MODEL_NVARS_+2] = vy-c;   D[2*_MODEL_NVARS_+3] = 0;    D[2*_MODEL_NVARS_+4] = 0; \
>       D[3*_MODEL_NVARS_+0] = 0;      D[3*_MODEL_NVARS_+1] = 0;    D[3*_MODEL_NVARS_+2] = 0;      D[3*_MODEL_NVARS_+3] = vy;   D[3*_MODEL_NVARS_+4] = 0; \
>       D[4*_MODEL_NVARS_+0] = 0;      D[4*_MODEL_NVARS_+1] = 0;    D[4*_MODEL_NVARS_+2] = 0;      D[4*_MODEL_NVARS_+3] = 0;    D[4*_MODEL_NVARS_+4] = vy+c;\
200,207c272,276
<       D[1*nvars+1] = vn; \
<       D[2*nvars+2] = vn;\
<       D[3*nvars+3] = vn+c; \
<     }\
<     D[4*nvars+4] = vn; \
<     int m_i; \
<     for (m_i = _NS3D_NVARS_; m_i < nvars; m_i++) { \
<       D[m_i*nvars+m_i] = vn; \
---
>       D[0*_MODEL_NVARS_+0] = vz;     D[0*_MODEL_NVARS_+1] = 0;    D[0*_MODEL_NVARS_+2] = 0;      D[0*_MODEL_NVARS_+3] = 0;    D[0*_MODEL_NVARS_+4] = 0; \
>       D[1*_MODEL_NVARS_+0] = 0;      D[1*_MODEL_NVARS_+1] = vz;   D[1*_MODEL_NVARS_+2] = 0;      D[1*_MODEL_NVARS_+3] = 0;    D[1*_MODEL_NVARS_+4] = 0; \
>       D[2*_MODEL_NVARS_+0] = 0;      D[2*_MODEL_NVARS_+1] = 0;    D[2*_MODEL_NVARS_+2] = vz;     D[2*_MODEL_NVARS_+3] = 0;    D[2*_MODEL_NVARS_+4] = 0; \
>       D[3*_MODEL_NVARS_+0] = 0;      D[3*_MODEL_NVARS_+1] = 0;    D[3*_MODEL_NVARS_+2] = 0;      D[3*_MODEL_NVARS_+3] = vz-c; D[3*_MODEL_NVARS_+4] = 0; \
>       D[4*_MODEL_NVARS_+0] = 0;      D[4*_MODEL_NVARS_+1] = 0;    D[4*_MODEL_NVARS_+2] = 0;      D[4*_MODEL_NVARS_+3] = 0;    D[4*_MODEL_NVARS_+4] = vz+c;\
219c288
< #define _NavierStokes3DLeftEigenvectors_(u,L,ga,nvars,dir) \
---
> #define _NavierStokes3DLeftEigenvectors_(u,stride,L,ga,dir) \
221,225c290,292
<     double ga_minus_one=ga-1.0; \
<     double rho,vx,vy,vz,e,P,a,un,ek,vsq; \
<     _NavierStokes3DGetFlowVar_(u,rho,vx,vy,vz,e,P,ga); \
<     double nx = 0,ny = 0,nz = 0; \
<     vsq  = (vx*vx) + (vy*vy) + (vz*vz); \
---
>     double  ga_minus_one=ga-1.0; \
>     double  rho,vx,vy,vz,e,P,a,ek; \
>     _NavierStokes3DGetFlowVar_(u,stride,rho,vx,vy,vz,e,P,ga); \
228d294
<     _ArraySetValue_(L, nvars*nvars, 0.0); \
230,256c296,320
<       un = vx; \
<       nx = 1.0; \
<       L[0*nvars+0] = (ga_minus_one*ek + a*un) / (2*a*a); \
<       L[0*nvars+1] = ((-ga_minus_one)*vx - a*nx) / (2*a*a); \
<       L[0*nvars+2] = ((-ga_minus_one)*vy - a*ny) / (2*a*a); \
<       L[0*nvars+3] = ((-ga_minus_one)*vz - a*nz) / (2*a*a); \
<       L[0*nvars+4] = ga_minus_one / (2*a*a); \
<       L[4*nvars+0] = (a*a - ga_minus_one*ek) / (a*a); \
<       L[4*nvars+1] = (ga_minus_one*vx) / (a*a); \
<       L[4*nvars+2] = (ga_minus_one*vy) / (a*a); \
<       L[4*nvars+3] = (ga_minus_one*vz) / (a*a); \
<       L[4*nvars+4] = (-ga_minus_one) / (a*a); \
<       L[1*nvars+0] = (ga_minus_one*ek - a*un) / (2*a*a); \
<       L[1*nvars+1] = ((-ga_minus_one)*vx + a*nx) / (2*a*a); \
<       L[1*nvars+2] = ((-ga_minus_one)*vy + a*ny) / (2*a*a); \
<       L[1*nvars+3] = ((-ga_minus_one)*vz + a*nz) / (2*a*a); \
<       L[1*nvars+4] = ga_minus_one / (2*a*a); \
<       L[2*nvars+0] = (vy - un*ny) / nx; \
<       L[2*nvars+1] = ny; \
<       L[2*nvars+2] = (ny*ny - 1.0) / nx; \
<       L[2*nvars+3] = 0.0; \
<       L[2*nvars+4] = 0.0; \
<       L[3*nvars+0] = (vz - un*nz) / nx; \
<       L[3*nvars+1] = nz; \
<       L[3*nvars+2] = 0.0; \
<       L[3*nvars+3] = (nz*nz - 1.0) / nx; \
<       L[3*nvars+4] = 0.0; \
---
>       L[1*_MODEL_NVARS_+0] = (ga_minus_one*ek + a*vx) / (2*a*a); \
>       L[1*_MODEL_NVARS_+1] = ((-ga_minus_one)*vx-a) / (2*a*a); \
>       L[1*_MODEL_NVARS_+2] = ((-ga_minus_one)*vy) / (2*a*a); \
>       L[1*_MODEL_NVARS_+3] = ((-ga_minus_one)*vz) / (2*a*a); \
>       L[1*_MODEL_NVARS_+4] = ga_minus_one / (2*a*a); \
>       L[0*_MODEL_NVARS_+0] = (a*a - ga_minus_one*ek) / (a*a); \
>       L[0*_MODEL_NVARS_+1] = (ga_minus_one*vx) / (a*a); \
>       L[0*_MODEL_NVARS_+2] = (ga_minus_one*vy) / (a*a); \
>       L[0*_MODEL_NVARS_+3] = (ga_minus_one*vz) / (a*a); \
>       L[0*_MODEL_NVARS_+4] = (-ga_minus_one) / (a*a); \
>       L[4*_MODEL_NVARS_+0] = (ga_minus_one*ek - a*vx) / (2*a*a); \
>       L[4*_MODEL_NVARS_+1] = ((-ga_minus_one)*vx+a) / (2*a*a); \
>       L[4*_MODEL_NVARS_+2] = ((-ga_minus_one)*vy) / (2*a*a); \
>       L[4*_MODEL_NVARS_+3] = ((-ga_minus_one)*vz) / (2*a*a); \
>       L[4*_MODEL_NVARS_+4] = ga_minus_one / (2*a*a); \
>       L[2*_MODEL_NVARS_+0] = vy; \
>       L[2*_MODEL_NVARS_+1] = 0.0; \
>       L[2*_MODEL_NVARS_+2] = -1.0; \
>       L[2*_MODEL_NVARS_+3] = 0.0; \
>       L[2*_MODEL_NVARS_+4] = 0.0; \
>       L[3*_MODEL_NVARS_+0] = -vz; \
>       L[3*_MODEL_NVARS_+1] = 0.0; \
>       L[3*_MODEL_NVARS_+2] = 0.0; \
>       L[3*_MODEL_NVARS_+3] = 1.0; \
>       L[3*_MODEL_NVARS_+4] = 0.0; \
258,284c322,346
<       un = vy;  \
<       ny = 1.0; \
<       L[0*nvars+0] = (ga_minus_one*ek+a*un) / (2*a*a); \
<       L[0*nvars+1] = ((1.0-ga)*vx - a*nx) / (2*a*a); \
<       L[0*nvars+2] = ((1.0-ga)*vy - a*ny) / (2*a*a); \
<       L[0*nvars+3] = ((1.0-ga)*vz - a*nz) / (2*a*a); \
<       L[0*nvars+4] = ga_minus_one / (2*a*a); \
<       L[4*nvars+0] = (a*a-ga_minus_one*ek) / (a*a); \
<       L[4*nvars+1] = ga_minus_one*vx / (a*a); \
<       L[4*nvars+2] = ga_minus_one*vy / (a*a); \
<       L[4*nvars+3] = ga_minus_one*vz / (a*a); \
<       L[4*nvars+4] = (1.0 - ga) / (a*a); \
<       L[2*nvars+0] = (ga_minus_one*ek-a*un) / (2*a*a); \
<       L[2*nvars+1] = ((1.0-ga)*vx + a*nx) / (2*a*a); \
<       L[2*nvars+2] = ((1.0-ga)*vy + a*ny) / (2*a*a); \
<       L[2*nvars+3] = ((1.0-ga)*vz + a*nz) / (2*a*a); \
<       L[2*nvars+4] = ga_minus_one / (2*a*a); \
<       L[1*nvars+0] = (un*nx-vx) / ny; \
<       L[1*nvars+1] = (1.0 - nx*nx) / ny; \
<       L[1*nvars+2] = - nx; \
<       L[1*nvars+3] = 0.0; \
<       L[1*nvars+4] = 0; \
<       L[3*nvars+0] = (vz - un*nz) / ny; \
<       L[3*nvars+1] = 0.0; \
<       L[3*nvars+2] = nz; \
<       L[3*nvars+3] = (nz*nz - 1.0) / ny; \
<       L[3*nvars+4] = 0.0; \
---
>       L[2*_MODEL_NVARS_+0] = (ga_minus_one*ek+a*vy) / (2*a*a); \
>       L[2*_MODEL_NVARS_+1] = ((1.0-ga)*vx) / (2*a*a); \
>       L[2*_MODEL_NVARS_+2] = ((1.0-ga)*vy-a) / (2*a*a); \
>       L[2*_MODEL_NVARS_+3] = ((1.0-ga)*vz) / (2*a*a); \
>       L[2*_MODEL_NVARS_+4] = ga_minus_one / (2*a*a); \
>       L[0*_MODEL_NVARS_+0] = (a*a-ga_minus_one*ek) / (a*a); \
>       L[0*_MODEL_NVARS_+1] = ga_minus_one*vx / (a*a); \
>       L[0*_MODEL_NVARS_+2] = ga_minus_one*vy / (a*a); \
>       L[0*_MODEL_NVARS_+3] = ga_minus_one*vz / (a*a); \
>       L[0*_MODEL_NVARS_+4] = (1.0 - ga) / (a*a); \
>       L[4*_MODEL_NVARS_+0] = (ga_minus_one*ek-a*vy) / (2*a*a); \
>       L[4*_MODEL_NVARS_+1] = ((1.0-ga)*vx) / (2*a*a); \
>       L[4*_MODEL_NVARS_+2] = ((1.0-ga)*vy+a) / (2*a*a); \
>       L[4*_MODEL_NVARS_+3] = ((1.0-ga)*vz) / (2*a*a); \
>       L[4*_MODEL_NVARS_+4] = ga_minus_one / (2*a*a); \
>       L[1*_MODEL_NVARS_+0] = -vx; \
>       L[1*_MODEL_NVARS_+1] = 1.0; \
>       L[1*_MODEL_NVARS_+2] = 0.0; \
>       L[1*_MODEL_NVARS_+3] = 0.0; \
>       L[1*_MODEL_NVARS_+4] = 0; \
>       L[3*_MODEL_NVARS_+0] = vz; \
>       L[3*_MODEL_NVARS_+1] = 0.0; \
>       L[3*_MODEL_NVARS_+2] = 0.0; \
>       L[3*_MODEL_NVARS_+3] = -1.0; \
>       L[3*_MODEL_NVARS_+4] = 0; \
286,316c348,372
<       un = vz;  \
<       nz = 1.0; \
<       L[0*nvars+0] = (ga_minus_one*ek+a*un) / (2*a*a); \
<       L[0*nvars+1] = ((1.0-ga)*vx - a*nx) / (2*a*a); \
<       L[0*nvars+2] = ((1.0-ga)*vy - a*ny) / (2*a*a); \
<       L[0*nvars+3] = ((1.0-ga)*vz - a*nz) / (2*a*a); \
<       L[0*nvars+4] = ga_minus_one / (2*a*a); \
<       L[4*nvars+0] = (a*a-ga_minus_one*ek) / (a*a); \
<       L[4*nvars+1] = ga_minus_one*vx / (a*a); \
<       L[4*nvars+2] = ga_minus_one*vy / (a*a); \
<       L[4*nvars+3] = ga_minus_one*vz / (a*a); \
<       L[4*nvars+4] = (1.0 - ga) / (a*a); \
<       L[3*nvars+0] = (ga_minus_one*ek-a*un) / (2*a*a); \
<       L[3*nvars+1] = ((1.0-ga)*vx + a*nx) / (2*a*a); \
<       L[3*nvars+2] = ((1.0-ga)*vy + a*ny) / (2*a*a); \
<       L[3*nvars+3] = ((1.0-ga)*vz + a*nz) / (2*a*a); \
<       L[3*nvars+4] = ga_minus_one / (2*a*a); \
<       L[1*nvars+0] = (un*nx-vx) / nz; \
<       L[1*nvars+1] = (1.0 - nx*nx) / nz; \
<       L[1*nvars+2] = 0.0; \
<       L[1*nvars+3] = - nx; \
<       L[1*nvars+4] = 0; \
<       L[2*nvars+0] = (un*ny-vy) / nz; \
<       L[2*nvars+1] = 0.0; \
<       L[2*nvars+2] = (1.0 - ny*ny) / nz; \
<       L[2*nvars+3] = - ny; \
<       L[2*nvars+4] = 0.0; \
<     } \
<     int m_i; \
<     for (m_i = _NS3D_NVARS_; m_i < nvars; m_i++) { \
<       L[m_i*nvars+m_i] = 1.0; \
---
>       L[3*_MODEL_NVARS_+0] = (ga_minus_one*ek+a*vz) / (2*a*a); \
>       L[3*_MODEL_NVARS_+1] = ((1.0-ga)*vx) / (2*a*a); \
>       L[3*_MODEL_NVARS_+2] = ((1.0-ga)*vy) / (2*a*a); \
>       L[3*_MODEL_NVARS_+3] = ((1.0-ga)*vz-a) / (2*a*a); \
>       L[3*_MODEL_NVARS_+4] = ga_minus_one / (2*a*a); \
>       L[0*_MODEL_NVARS_+0] = (a*a-ga_minus_one*ek) / (a*a); \
>       L[0*_MODEL_NVARS_+1] = ga_minus_one*vx / (a*a); \
>       L[0*_MODEL_NVARS_+2] = ga_minus_one*vy / (a*a); \
>       L[0*_MODEL_NVARS_+3] = ga_minus_one*vz / (a*a); \
>       L[0*_MODEL_NVARS_+4] = (1.0-ga) / (a*a); \
>       L[4*_MODEL_NVARS_+0] = (ga_minus_one*ek-a*vz) / (2*a*a); \
>       L[4*_MODEL_NVARS_+1] = ((1.0-ga)*vx) / (2*a*a); \
>       L[4*_MODEL_NVARS_+2] = ((1.0-ga)*vy) / (2*a*a); \
>       L[4*_MODEL_NVARS_+3] = ((1.0-ga)*vz+a) / (2*a*a); \
>       L[4*_MODEL_NVARS_+4] = ga_minus_one / (2*a*a); \
>       L[1*_MODEL_NVARS_+0] = vx; \
>       L[1*_MODEL_NVARS_+1] = -1.0; \
>       L[1*_MODEL_NVARS_+2] = 0.0; \
>       L[1*_MODEL_NVARS_+3] = 0.0; \
>       L[1*_MODEL_NVARS_+4] = 0; \
>       L[2*_MODEL_NVARS_+0] = -vy; \
>       L[2*_MODEL_NVARS_+1] = 0.0; \
>       L[2*_MODEL_NVARS_+2] = 1.0; \
>       L[2*_MODEL_NVARS_+3] = 0.0; \
>       L[2*_MODEL_NVARS_+4] = 0; \
328c384
< #define _NavierStokes3DRightEigenvectors_(u,R,ga,nvars,dir) \
---
> #define _NavierStokes3DRightEigenvectors_(u,stride,R,ga,dir) \
330,334c386,388
<     double ga_minus_one = ga-1.0; \
<     double rho,vx,vy,vz,e,P,un,ek,a,h0,vsq; \
<     _NavierStokes3DGetFlowVar_(u,rho,vx,vy,vz,e,P,ga); \
<     double nx = 0,ny = 0,nz = 0; \
<     vsq  = (vx*vx) + (vy*vy) + (vz*vz); \
---
>     double  ga_minus_one = ga-1.0; \
>     double  rho,vx,vy,vz,e,P,ek,a,h0; \
>     _NavierStokes3DGetFlowVar_(u,stride,rho,vx,vy,vz,e,P,ga); \
338d391
<     _ArraySetValue_(R, nvars*nvars, 0.0); \
340,366c393,417
<       un = vx; \
<       nx = 1.0; \
<       R[0*nvars+0] = 1.0; \
<       R[1*nvars+0] = vx - a*nx; \
<       R[2*nvars+0] = vy - a*ny; \
<       R[3*nvars+0] = vz - a*nz; \
<       R[4*nvars+0] = h0 - a*un; \
<       R[0*nvars+4] = 1.0; \
<       R[1*nvars+4] = vx; \
<       R[2*nvars+4] = vy; \
<       R[3*nvars+4] = vz; \
<       R[4*nvars+4] = ek; \
<       R[0*nvars+1] = 1.0; \
<       R[1*nvars+1] = vx + a*nx; \
<       R[2*nvars+1] = vy + a*ny; \
<       R[3*nvars+1] = vz + a*nz; \
<       R[4*nvars+1] = h0 + a*un; \
<       R[0*nvars+2] = 0.0; \
<       R[1*nvars+2] = ny; \
<       R[2*nvars+2] = -nx; \
<       R[3*nvars+2] = 0.0; \
<       R[4*nvars+2] = vx*ny - vy*nx; \
<       R[0*nvars+3] = 0.0; \
<       R[1*nvars+3] = nz; \
<       R[2*nvars+3] = 0.0; \
<       R[3*nvars+3] = -nx; \
<       R[4*nvars+3] = vx*nz - vz*nx; \
---
>       R[0*_MODEL_NVARS_+1] = 1.0; \
>       R[1*_MODEL_NVARS_+1] = vx-a; \
>       R[2*_MODEL_NVARS_+1] = vy; \
>       R[3*_MODEL_NVARS_+1] = vz; \
>       R[4*_MODEL_NVARS_+1] = h0 - a*vx; \
>       R[0*_MODEL_NVARS_+0] = 1.0; \
>       R[1*_MODEL_NVARS_+0] = vx; \
>       R[2*_MODEL_NVARS_+0] = vy; \
>       R[3*_MODEL_NVARS_+0] = vz; \
>       R[4*_MODEL_NVARS_+0] = ek; \
>       R[0*_MODEL_NVARS_+4] = 1.0; \
>       R[1*_MODEL_NVARS_+4] = vx+a; \
>       R[2*_MODEL_NVARS_+4] = vy; \
>       R[3*_MODEL_NVARS_+4] = vz; \
>       R[4*_MODEL_NVARS_+4] = h0 + a*vx; \
>       R[0*_MODEL_NVARS_+2] = 0.0; \
>       R[1*_MODEL_NVARS_+2] = 0.0; \
>       R[2*_MODEL_NVARS_+2] = -1.0; \
>       R[3*_MODEL_NVARS_+2] = 0.0; \
>       R[4*_MODEL_NVARS_+2] = -vy; \
>       R[0*_MODEL_NVARS_+3] = 0.0; \
>       R[1*_MODEL_NVARS_+3] = 0.0; \
>       R[2*_MODEL_NVARS_+3] = 0.0; \
>       R[3*_MODEL_NVARS_+3] = 1.0; \
>       R[4*_MODEL_NVARS_+3] = vz; \
368,426c419,469
<       un = vy; \
<       ny = 1.0; \
<       R[0*nvars+0] = 1.0; \
<       R[1*nvars+0] = vx - a*nx; \
<       R[2*nvars+0] = vy - a*ny; \
<       R[3*nvars+0] = vz - a*nz; \
<       R[4*nvars+0] = h0 - a*un; \
<       R[0*nvars+4] = 1.0; \
<       R[1*nvars+4] = vx; \
<       R[2*nvars+4] = vy; \
<       R[3*nvars+4] = vz; \
<       R[4*nvars+4] = ek; \
<       R[0*nvars+2] = 1.0; \
<       R[1*nvars+2] = vx + a*nx; \
<       R[2*nvars+2] = vy + a*ny; \
<       R[3*nvars+2] = vz + a*nz; \
<       R[4*nvars+2] = h0 + a*un; \
<       R[0*nvars+1] = 0; \
<       R[1*nvars+1] = ny; \
<       R[2*nvars+1] = -nx; \
<       R[3*nvars+1] = 0.0; \
<       R[4*nvars+1] = vx*ny-vy*nx; \
<       R[0*nvars+3] = 0.0; \
<       R[1*nvars+3] = 0.0; \
<       R[2*nvars+3] = nz; \
<       R[3*nvars+3] = -ny; \
<       R[4*nvars+3] = vy*nz - vz*ny; \
<     } else if (dir == _ZDIR_) { \
<       un = vz; \
<       nz = 1.0; \
<       R[0*nvars+0] = 1.0; \
<       R[1*nvars+0] = vx - a*nx; \
<       R[2*nvars+0] = vy - a*ny; \
<       R[3*nvars+0] = vz - a*nz; \
<       R[4*nvars+0] = h0 - a*un; \
<       R[0*nvars+4] = 1.0; \
<       R[1*nvars+4] = vx; \
<       R[2*nvars+4] = vy; \
<       R[3*nvars+4] = vz; \
<       R[4*nvars+4] = ek; \
<       R[0*nvars+3] = 1.0; \
<       R[1*nvars+3] = vx + a*nx; \
<       R[2*nvars+3] = vy + a*ny; \
<       R[3*nvars+3] = vz + a*nz; \
<       R[4*nvars+3] = h0 + a*un; \
<       R[0*nvars+1] = 0; \
<       R[1*nvars+1] = nz; \
<       R[2*nvars+1] = 0.0; \
<       R[3*nvars+1] = -nx; \
<       R[4*nvars+1] = vx*nz-vz*nx; \
<       R[0*nvars+2] = 0.0; \
<       R[1*nvars+2] = 0.0; \
<       R[2*nvars+2] = nz; \
<       R[3*nvars+2] = -ny; \
<       R[4*nvars+2] = vy*nz - vz*ny; \
<     } \
<     int m_i; \
<     for (m_i = _NS3D_NVARS_; m_i < nvars; m_i++) { \
<       R[m_i*nvars+m_i] = 1.0; \
---
>       R[0*_MODEL_NVARS_+2] = 1.0; \
>       R[1*_MODEL_NVARS_+2] = vx; \
>       R[2*_MODEL_NVARS_+2] = vy-a; \
>       R[3*_MODEL_NVARS_+2] = vz; \
>       R[4*_MODEL_NVARS_+2] = h0 - a*vy; \
>       R[0*_MODEL_NVARS_+0] = 1.0; \
>       R[1*_MODEL_NVARS_+0] = vx; \
>       R[2*_MODEL_NVARS_+0] = vy; \
>       R[3*_MODEL_NVARS_+0] = vz; \
>       R[4*_MODEL_NVARS_+0] = ek; \
>       R[0*_MODEL_NVARS_+4] = 1.0; \
>       R[1*_MODEL_NVARS_+4] = vx; \
>       R[2*_MODEL_NVARS_+4] = vy+a; \
>       R[3*_MODEL_NVARS_+4] = vz; \
>       R[4*_MODEL_NVARS_+4] = h0 + a*vy; \
>       R[0*_MODEL_NVARS_+1] = 0.0; \
>       R[1*_MODEL_NVARS_+1] = 1.0; \
>       R[2*_MODEL_NVARS_+1] = 0.0; \
>       R[3*_MODEL_NVARS_+1] = 0.0; \
>       R[4*_MODEL_NVARS_+1] = vx; \
>       R[0*_MODEL_NVARS_+3] = 0.0; \
>       R[1*_MODEL_NVARS_+3] = 0.0; \
>       R[2*_MODEL_NVARS_+3] = 0.0; \
>       R[3*_MODEL_NVARS_+3] = -1.0; \
>       R[4*_MODEL_NVARS_+3] = -vz; \
>     } else if (dir == _ZDIR_) {  \
>       R[0*_MODEL_NVARS_+3] = 1.0; \
>       R[1*_MODEL_NVARS_+3] = vx; \
>       R[2*_MODEL_NVARS_+3] = vy; \
>       R[3*_MODEL_NVARS_+3] = vz-a; \
>       R[4*_MODEL_NVARS_+3] = h0-a*vz; \
>       R[0*_MODEL_NVARS_+0] = 1.0; \
>       R[1*_MODEL_NVARS_+0] = vx; \
>       R[2*_MODEL_NVARS_+0] = vy; \
>       R[3*_MODEL_NVARS_+0] = vz; \
>       R[4*_MODEL_NVARS_+0] = ek; \
>       R[0*_MODEL_NVARS_+4] = 1.0; \
>       R[1*_MODEL_NVARS_+4] = vx; \
>       R[2*_MODEL_NVARS_+4] = vy; \
>       R[3*_MODEL_NVARS_+4] = vz+a; \
>       R[4*_MODEL_NVARS_+4] = h0+a*vz; \
>       R[0*_MODEL_NVARS_+1] = 0.0; \
>       R[1*_MODEL_NVARS_+1] = -1.0; \
>       R[2*_MODEL_NVARS_+1] = 0.0; \
>       R[3*_MODEL_NVARS_+1] = 0.0; \
>       R[4*_MODEL_NVARS_+1] = -vx; \
>       R[0*_MODEL_NVARS_+2] = 0.0; \
>       R[1*_MODEL_NVARS_+2] = 0.0; \
>       R[2*_MODEL_NVARS_+2] = 1.0; \
>       R[3*_MODEL_NVARS_+2] = 0.0; \
>       R[4*_MODEL_NVARS_+2] = vy; \
430,449d472
< /*! \def _NavierStokes3DCoeffViscosity_
<     Compute the viscosity coefficient given the temperature */
< #define _NavierStokes3DCoeffViscosity_(mu, T_norm, param) \
<   { \
<     double T_d = T_norm*param->Tref;  \
<     mu = raiseto(T_d/param->T0, 1.5)  \
<          * (param->T0 + param->TS)  \
<          / (T_d       + param->TS); \
<   }
< 
< /*! \def _NavierStokes3DCoeffConductivity_
<     Compute the conductivity coefficient given the temperature */
< #define _NavierStokes3DCoeffConductivity_(kappa, T_norm, param) \
<   { \
<     double T_d = T_norm*param->Tref; \
<     kappa = raiseto(T_d/param->T0, 1.5)                                   \
<             * (param->T0 + param->TA * exp(-param->TB/param->T0))       \
<             / (T_d       + param->TA * exp(-param->TB/T_d      )); \
<   }
< 
460,477c483,549
<   double  gamma;                          /*!< Ratio of heat capacities */
<   char    upw_choice[_MAX_STRING_SIZE_];  /*!< choice of upwinding */
<   double  Re;                             /*!< Reynolds number */
<   double  Pr;                             /*!< Prandtl  number */
< 
<   int include_chem; /*!< Flag to include chemistry */
<   void* chem; /*!< Photochemical reactions object */
< 
<   int nvars; /*!< Number of variables per grid point */
<   char write_op[_MAX_STRING_SIZE_]; /*!< Write physics-specific output to file */
< 
<   // constants for computing viscosity and conductivity coefficients
<   double Tref; /*!< Reference temperature */
<   double T0; /*!< T_0 (in Kelvins) (viscoscity/conductivity coeff) */
<   double TS; /*!< T_S (in Kelvins) (viscoscity/conductivity coeff) */
<   double TA; /*!< T_A (in Kelvins) (viscoscity/conductivity coeff) */
<   double TB; /*!< T_A (in Kelvins) (viscoscity/conductivity coeff) */
< 
---
>   double  gamma;  /*!< Ratio of heat capacities */
>   double  Re;     /*!< Reynolds number */
>   double  Pr;     /*!< Prandtl  number */
>   double  Minf;   /*!< Freestream Mach number */
>   double  C1,     /*!< Sutherlands law constant */
>           C2;     /*!< Sutherlands law constant */
>   double  grav_x,                         /*!< acceleration due to gravity in x */
>           grav_y,                         /*!< acceleration due to gravity in y */
>           grav_z;                         /*!< acceleration due to gravity in z */
>   double  rho0;                           /*!< reference density  at zero altitude for flows with gravity */
>   double  p0;                             /*!< reference pressure at zero altitude for flows with gravity */
>   double  R;                              /*!< universal Gas constant */
>   char    upw_choice[_MAX_STRING_SIZE_]; /*!< choice of upwinding */
> 
>   double  *grav_field_f, /*!< density variation function (\f$\varrho\f$) for hydrostatic equilibrium for flows with gravity */
>           *grav_field_g; /*!< pressure variation function (\f$\varrho\f$) for hydrostatic equilibrium for flows with gravity */
> 
>   double *fast_jac, /*!< "Fast" Jacobian of the flux function (comprising the acoustic modes) */
>          *solution; /*!< array to store the solution at the beginning of each time step */
> 
>   /*! Type of immersed boundary wall: isothermal or adiabatic */
>   char ib_wall_type[_MAX_STRING_SIZE_];
>   /*! Immersed body wall temperature, if isothermal */
>   double T_ib_wall;
> 
>   /* choice of hydrostatic balance                              */
>   /* 1 -> isothermal                                            */
>   /* 2 -> constant potential temperature                        */
>   /* 3 -> stratified atmosphere with a Brunt-Vaisala frequency  */
>   int HB /*!< Choice of hydrostatic balance for flows with gravity (1 - isothermal equilibrium,
>                                                                     2 - constant potential temperature
>                                                                     3 - stratified atmosphere with a Brunt-Vaisala frequency) */;
>   double N_bv; /*!< the Brunt-Vaisala frequency for #NavierStokes3D::HB = 3 */
> 
>   char ib_write_surface_data[_MAX_STRING_SIZE_]; /*!< Flag to indicate whether to analyze and write surface data for
>                                                       immersed body, if present. Applicable only if #HyPar::flag_ib is 1 */
> 
>   /*! Time scale to ramp up the application of immersed boundary conditions,
>       applicable only if #HyPar::flag_ib is 1 */
>   double t_ib_ramp;
> 
>   /*! The "gentleness" with which to ramp up the application of immersed boundary conditions,
>       applicable only if #HyPar::flag_ib is 1 */
>   double t_ib_width;
> 
>   /*! Type of ramp up the application of immersed boundary conditions
>       (linear, exponential, etc.),
>       applicable only if #HyPar::flag_ib is 1 */
>   char ib_ramp_type[_MAX_STRING_SIZE_];
> 
>   /*! Isothermal immersed boundary temperature tolerance: if ghost point temperature
>       differs from wall temperature by more than this factor, set it to the wall
>       temperature - sort of a limiting */
>   double ib_T_tol;
> 
> #if defined(HAVE_CUDA)
>   double *gpu_Q;
>   double *gpu_QDerivX;
>   double *gpu_QDerivY;
>   double *gpu_QDerivZ;
>   double *gpu_FViscous;
>   double *gpu_FDeriv;
>   double *gpu_grav_field_f;
>   double *gpu_grav_field_g;
>   double *gpu_fast_jac;
>   double *gpu_solution;
> #endif
480,481c552,557
< int    NavierStokes3DInitialize (void*,void*);
< int    NavierStokes3DCleanup    (void*);
---
> int NavierStokes3DInitialize (void*,void*);
> int NavierStokes3DCleanup    (void*);
> 
> #if defined(HAVE_CUDA)
> int gpuNavierStokes3DCleanup (void*);
> #endif
482a559
> static const int _NavierStokes3D_stride_ = 1;
